<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hard DJ Mix — простая веб-версия диджея</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: #080812; color: #e6eef8; font-family: Inter, system-ui, sans-serif; }
    .card { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); }
    canvas { background: #050515; border-radius:8px; }
    .knob { -webkit-appearance:none; appearance:none; height:36px; }
  </style>
</head>
<body class="p-6">
  <div class="max-w-5xl mx-auto">
    <header class="flex items-center justify-between mb-4">
      <h1 class="text-2xl font-bold">Hard DJ Mix — миксуй жёстко</h1>
      <div class="text-sm text-white/60">Прототип — всё работает локально в браузере</div>
    </header>

    <main class="grid grid-cols-2 gap-4">
      <!-- Deck A -->
      <section class="card p-4 rounded-xl">
        <h2 class="font-semibold">Deck A</h2>
        <input class="mt-2" type="file" accept="audio/*" id="fileA" />
        <div class="mt-3 flex gap-2 items-center">
          <button id="playA" class="px-3 py-2 bg-green-600 rounded">Play</button>
          <button id="pauseA" class="px-3 py-2 bg-red-600 rounded">Pause</button>
          <button id="cueA" class="px-3 py-2 bg-slate-600 rounded">Cue</button>
          <div class="ml-auto text-xs">BPM: <span id="bpmA">—</span></div>
        </div>

        <div class="mt-3 grid grid-cols-2 gap-3">
          <label class="text-xs">Gain<br><input id="gainA" type="range" min="0" max="2" step="0.01" value="1" /></label>
          <label class="text-xs">Pitch<br><input id="pitchA" type="range" min="0.5" max="1.5" step="0.001" value="1" /></label>
        </div>

        <div class="mt-3">
          <canvas id="vizA" width="600" height="100"></canvas>
        </div>

        <div class="mt-3 text-xs text-white/60">Перетяни трек или выбери файл. Pitch меняет скорость, gain — громкость.</div>
      </section>

      <!-- Deck B -->
      <section class="card p-4 rounded-xl">
        <h2 class="font-semibold">Deck B</h2>
        <input class="mt-2" type="file" accept="audio/*" id="fileB" />
        <div class="mt-3 flex gap-2 items-center">
          <button id="playB" class="px-3 py-2 bg-green-600 rounded">Play</button>
          <button id="pauseB" class="px-3 py-2 bg-red-600 rounded">Pause</button>
          <button id="cueB" class="px-3 py-2 bg-slate-600 rounded">Cue</button>
          <div class="ml-auto text-xs">BPM: <span id="bpmB">—</span></div>
        </div>

        <div class="mt-3 grid grid-cols-2 gap-3">
          <label class="text-xs">Gain<br><input id="gainB" type="range" min="0" max="2" step="0.01" value="1" /></label>
          <label class="text-xs">Pitch<br><input id="pitchB" type="range" min="0.5" max="1.5" step="0.001" value="1" /></label>
        </div>

        <div class="mt-3">
          <canvas id="vizB" width="600" height="100"></canvas>
        </div>

        <div class="mt-3 text-xs text-white/60">Есть кью, визуализатор и базовые эффекты.</div>
      </section>

      <!-- Mixer / Crossfader -->
      <section class="col-span-2 card p-4 rounded-xl mt-2">
        <h3 class="font-semibold">Mixer</h3>
        <div class="mt-3 grid grid-cols-3 gap-4 items-center">
          <div>
            <label class="text-xs">Crossfader</label>
            <input id="crossfader" type="range" min="0" max="1" step="0.01" value="0.5" class="w-full" />
          </div>
          <div>
            <label class="text-xs">Master Volume</label>
            <input id="master" type="range" min="0" max="1.5" step="0.01" value="1" class="w-full" />
          </div>
          <div>
            <label class="text-xs">Echo on/off</label><br>
            <button id="echoBtn" class="px-3 py-2 bg-amber-500 rounded mt-2">Toggle Echo</button>
          </div>
        </div>

        <div class="mt-4 flex gap-3 items-center">
          <button id="syncBtn" class="px-3 py-2 bg-indigo-600 rounded">Auto Sync BPM</button>
          <button id="recordBtn" class="px-3 py-2 bg-rose-600 rounded">Start/Stop Recording</button>
          <div class="ml-auto text-xs text-white/60">Горячие клавиши: A/C — play/pause A/B, Z/X — pitch down/up</div>
        </div>

        <div class="mt-4">
          <canvas id="masterViz" width="1200" height="120"></canvas>
        </div>
      </section>
    </main>

    <footer class="mt-4 text-xs text-white/60">Хочешь добавить автосинхронизацию, сохранение микса, эффекты или интерфейс в стиле фейерверк — скажи.</footer>
  </div>

  <script>
    // Простая DJ логика на WebAudio
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioContextClass();

    // deck structure
    function createDeck(){
      const gain = ctx.createGain();
      const playback = { element: new Audio(), source: null };
      const analyser = ctx.createAnalyser(); analyser.fftSize = 2048;
      const deck = { gain, playback, analyser, trackBuffer: null };
      gain.connect(analyser).connect(ctx.destination);
      return deck;
    }

    const deckA = createDeck();
    const deckB = createDeck();

    // master nodes
    const masterGain = ctx.createGain(); masterGain.gain.value = 1; masterGain.connect(ctx.destination);
    // We will route deck gains into masterGain instead of destination directly
    // Reconnect decks to masterGain
    deckA.gain.disconnect(); deckB.gain.disconnect();
    deckA.gain.connect(masterGain); deckB.gain.connect(masterGain);

    // Echo effect
    const delay = ctx.createDelay(5.0); delay.delayTime.value = 0.25;
    const fb = ctx.createGain(); fb.gain.value = 0.3;
    let echoOn = false;

    // helper: load file to buffer and also set HTMLAudioElement src for easy control
    async function loadToDeck(file, deck, audioEl){
      if(!file) return;
      const url = URL.createObjectURL(file);
      audioEl.src = url; audioEl.crossOrigin = "anonymous";
      // create media element source
      try{ if(deck.playback.source) deck.playback.source.disconnect(); }catch(e){}
      deck.playback.source = ctx.createMediaElementSource(audioEl);
      deck.playback.source.connect(deck.gain);
      // optional: fetch ArrayBuffer for waveform/BPM detection
      const ab = await file.arrayBuffer();
      deck.trackBuffer = await ctx.decodeAudioData(ab.slice(0));
    }

    // file inputs
    const fileA = document.getElementById('fileA'); const fileB = document.getElementById('fileB');
    fileA.addEventListener('change', async (e)=>{ await loadToDeck(e.target.files[0], deckA, deckA.playback.element); detectBPM(deckA, 'bpmA'); });
    fileB.addEventListener('change', async (e)=>{ await loadToDeck(e.target.files[0], deckB, deckB.playback.element); detectBPM(deckB, 'bpmB'); });

    // play/pause/cue
    document.getElementById('playA').onclick = ()=>{ resumeCtx(); deckA.playback.element.play(); };
    document.getElementById('pauseA').onclick = ()=> deckA.playback.element.pause();
    document.getElementById('cueA').onclick = ()=> { deckA.playback.element.currentTime = 0; }
    document.getElementById('playB').onclick = ()=>{ resumeCtx(); deckB.playback.element.play(); };
    document.getElementById('pauseB').onclick = ()=> deckB.playback.element.pause();
    document.getElementById('cueB').onclick = ()=> { deckB.playback.element.currentTime = 0; }

    // gains and pitch
    document.getElementById('gainA').addEventListener('input', e=> deckA.gain.gain.value = parseFloat(e.target.value));
    document.getElementById('gainB').addEventListener('input', e=> deckB.gain.gain.value = parseFloat(e.target.value));
    document.getElementById('pitchA').addEventListener('input', e=> deckA.playback.element.playbackRate = parseFloat(e.target.value));
    document.getElementById('pitchB').addEventListener('input', e=> deckB.playback.element.playbackRate = parseFloat(e.target.value));

    // crossfader: 0 -> full A, 1 -> full B
    const cross = document.getElementById('crossfader');
    cross.addEventListener('input', ()=>{
      const v = parseFloat(cross.value);
      deckA.gain.gain.value = (1 - v) * parseFloat(document.getElementById('gainA').value);
      deckB.gain.gain.value = v * parseFloat(document.getElementById('gainB').value);
    });

    // master
    document.getElementById('master').addEventListener('input', e=> masterGain.gain.value = parseFloat(e.target.value));

    // echo toggle
    document.getElementById('echoBtn').addEventListener('click', ()=>{
      echoOn = !echoOn;
      if(echoOn){ masterGain.disconnect(); masterGain.connect(delay); delay.connect(fb); fb.connect(delay); fb.connect(ctx.destination); delay.connect(ctx.destination); } else {
        try{ delay.disconnect(); fb.disconnect(); }catch(e){}; masterGain.disconnect(); masterGain.connect(ctx.destination);
      }
      alert('Echo ' + (echoOn? 'ON' : 'OFF'));
    });

    // Auto sync BPM (simple approach: set playbackRate ratio)
    document.getElementById('syncBtn').addEventListener('click', ()=>{
      if(!deckA.trackBuffer || !deckB.trackBuffer) return alert('Загрузите оба трека');
      Promise.all([estimateBPM(deckA.trackBuffer), estimateBPM(deckB.trackBuffer)]).then(vals=>{
        const [bA,bB] = vals; if(!bA || !bB) return alert('Не удалось определить BPM');
        const target = bA; const ratio = target / bB; deckB.playback.element.playbackRate = ratio; document.getElementById('pitchB').value = ratio; alert(`Sync: B set to ${ratio.toFixed(3)}x (target ${target.toFixed(1)} BPM)`);
      });
    });

    // Recording (MediaRecorder from destination stream)
    let mediaRecorder, chunks = [];
    document.getElementById('recordBtn').addEventListener('click', async ()=>{
      if(!mediaRecorder || mediaRecorder.state === 'inactive'){
        const dest = ctx.createMediaStreamDestination(); masterGain.connect(dest);
        mediaRecorder = new MediaRecorder(dest.stream);
        mediaRecorder.ondataavailable = e=>chunks.push(e.data);
        mediaRecorder.onstop = ()=>{
          const blob = new Blob(chunks, { type:'audio/webm' }); chunks = [];
          const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='mix.webm'; a.click();
        };
        mediaRecorder.start(); alert('Recording started');
      } else { mediaRecorder.stop(); alert('Recording stopped and downloaded'); }
    });

    // Visualizers
    const vizA = document.getElementById('vizA'); const ctxA = vizA.getContext('2d'); const vizB = document.getElementById('vizB'); const ctxB = vizB.getContext('2d'); const masterViz = document.getElementById('masterViz'); const mctx = masterViz.getContext('2d');
    function draw(){ requestAnimationFrame(draw);
      drawAnalyser(deckA.analyser, ctxA, vizA);
      drawAnalyser(deckB.analyser, ctxB, vizB);
      // master simple meter
      mctx.clearRect(0,0,masterViz.width, masterViz.height);
      mctx.fillStyle = '#33ddff'; mctx.fillRect(0, masterViz.height/2 - 10, (Math.random()*0.5+0.1)*masterViz.width, 20);
    }
    function drawAnalyser(analyser, c, canvas){ const w=canvas.width, h=canvas.height; const arr = new Uint8Array(analyser.frequencyBinCount); analyser.getByteTimeDomainData(arr); c.fillStyle='#050515'; c.fillRect(0,0,w,h); c.beginPath(); c.lineWidth=2; c.strokeStyle='#7c3aed'; let slice = w/arr.length; let x=0; for(let i=0;i<arr.length;i++){ const v = arr[i]/128.0; const y = v*h/2; if(i===0) c.moveTo(x,y); else c.lineTo(x,y); x+=slice; } c.stroke(); }
    draw();

    // Simple BPM detection helpers (very rough)
    function detectBPM(deck, labelId){ if(!deck.trackBuffer) return; estimateBPM(deck.trackBuffer).then(bpm=>{ document.getElementById(labelId).textContent = bpm? bpm.toFixed(1) : '—'; }); }

    async function estimateBPM(audioBuffer){ // very rough: use autocorrelation on mono mixdown of first 30s
      const raw = audioBuffer.getChannelData(0); const sampleRate = audioBuffer.sampleRate; const len = Math.min(raw.length, sampleRate*30); const data = raw.subarray(0, len);
      // downsample to 8000
      const dsRate = 8000; const factor = Math.max(1, Math.floor(sampleRate / dsRate)); const ds = new Float32Array(Math.floor(data.length/factor)); for(let i=0;i<ds.length;i++) ds[i]=data[i*factor];
      // energy-based onset autocorrelation
      const ac = new Float32Array(2000);
      for(let lag=0; lag<ac.length; lag++){ let sum=0; for(let i=0;i+lag<ds.length;i++){ sum += Math.abs(ds[i]) * Math.abs(ds[i+lag]); } ac[lag]=sum; }
      // find peak in reasonable BPM range 60-180 => lag in samples
      const minBpm=60, maxBpm=180; const minLag = Math.floor((60/maxBpm)* (dsRate)); const maxLag = Math.floor((60/minBpm) * (dsRate)); let best=0,bestVal=0; for(let lag=minLag; lag<=maxLag; lag++){ if(ac[lag]>bestVal){ bestVal=ac[lag]; best=lag; } }
      if(best===0) return null; const bpm = 60 / (best / dsRate); return bpm;
    }

    // helper resume ctx on user gesture
    function resumeCtx(){ if(ctx.state==='suspended') ctx.resume(); }

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key==='a'){ deckA.playback.element.play(); }
      if(e.key==='c'){ deckB.playback.element.play(); }
      if(e.key==='z'){ const p = parseFloat(document.getElementById('pitchA').value); document.getElementById('pitchA').value = (p-0.01).toFixed(3); deckA.playback.element.playbackRate = parseFloat(document.getElementById('pitchA').value); }
      if(e.key==='x'){ const p = parseFloat(document.getElementById('pitchA').value); document.getElementById('pitchA').value = (p+0.01).toFixed(3); deckA.playback.element.playbackRate = parseFloat(document.getElementById('pitchA').value); }
    });

    // very simple BPM estimate when user loads
    // done in loadToDeck -> detectBPM

  </script>
</body>
</html>
